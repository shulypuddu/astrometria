import json

# Contenido del notebook dividido por los separadores #%%
cells = [
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# Práctico 3 - Astrometría\n",
            "## Análisis de datos de galaxias"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# LIBRERIAS A USAR Y CARGA DE DATOS\n",
            "import pandas as pd\n",
            "import numpy as np\n",
            "import matplotlib.pyplot as plt\n",
            "import seaborn as sns\n",
            "import scipy.stats as st\n",
            "import scipy.optimize as opt\n",
            "\n",
            "\n",
            "sns.set_palette(\"Accent\") \n",
            "# Cargo los archivos y descarto las galaxias con blueshift\n",
            "df0 = pd.read_csv('/mnt/sda2/astrometria/practico_3/P3_shulypuddu.csv')\n",
            "df = df0[(df0['z'] > 0) & ((df0['u']-df0['r']) > 0.25) & ((df0['u']-df0['r']) < 4.5)]\n",
            "\n",
            "# Separo en rojas y azules\n",
            "rojo = df[(df['u']-df['r'])>2.5]\n",
            "azul = df[(df['u']-df['r'])<2.5]\n",
            "color_r = '#cd5c5c' #indianred\n",
            "color_a = '#4169e1' #royalblue\n",
            "\n",
            "# Separo en elipticas y espirales usando ZOOVOTES\n",
            "elip = df[df['elip']>0.8]\n",
            "esp = df[df['esp']>0.8]\n",
            "mer = df[df['meg']>0.8]\n",
            "\n",
            "# Separo en bulge y disco usando fracDeV_r\n",
            "bulge = df[df['fracDeV_r']>0.8]\n",
            "disco = df[df['fracDeV_r']<0.2]\n",
            "\n",
            "ur = (df['u']-df['r']).dropna()\n",
            "gr = (df['g']-df['r']).dropna()\n",
            "ug = (df['u']-df['g']).dropna()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# AJUSTE LINEAL CASERO\n",
            "def cuad_min(x, y):\n",
            "    \"\"\"\n",
            "    --Parámetros--\n",
            "    x, y : pandas Series o arrays \n",
            "    --Retorna--\n",
            "    Los coeficientes a y b de la recta y = ax + b\n",
            "    \"\"\"\n",
            "    _x = x.values  # Convertir a numpy array\n",
            "    _y = y.values \n",
            "    \n",
            "    # Calcular medias\n",
            "    x_medio = np.mean(_x)\n",
            "    y_medio = np.mean(_y)\n",
            "    \n",
            "    # Calcular diferencias (como arrays, no listas)\n",
            "    delta_x = _x - x_medio\n",
            "    delta_y = _y - y_medio\n",
            "    \n",
            "    # Fórmulas de mínimos cuadrados\n",
            "    a = np.sum(delta_x * delta_y) / np.sum(delta_x**2)\n",
            "    b = y_medio - a * x_medio\n",
            "    \n",
            "    return a, b\n",
            "\n",
            "# Calculo la recta\n",
            "muestra = df.sample(frac=0.05, random_state=252)\n",
            "a, b = cuad_min(muestra['g'], muestra['r'])\n",
            "y = a * muestra['g'] + b\n",
            "\n",
            "# AJUSTE DOBLE GAUSSIANA\n",
            "\n",
            "def doble_gaussiana(x, amp1, mu1, sigma1, amp2, mu2, sigma2):\n",
            "    return (amp1 * np.exp(-(x - mu1)**2 / (2 * sigma1**2)) +\n",
            "            amp2 * np.exp(-(x - mu2)**2 / (2 * sigma2**2)))\n",
            "\n",
            "def gauss(x,amp,mu,sigma):\n",
            "    return amp * np.exp(-(x - mu)**2 / (2 * sigma**2))\n",
            "\n",
            "chi=[]\n",
            "cuentas, bordes = np.histogram(ur, bins=50,density=True)\n",
            "centros = (bordes[:-1] + bordes[1:]) / 2\n",
            "\n",
            "# Estimaciones iniciales para los parámetros\n",
            "p0 = [1, ur.mean()-0.5, ur.std()/2, 1,ur.mean()+0.5, ur.std()/2]\n",
            "\n",
            "# Ajuste\n",
            "params, cov = opt.curve_fit(doble_gaussiana, centros, cuentas, p0=p0)\n",
            "\n",
            "x_fit = np.linspace(ur.min(), ur.max(), 200)\n",
            "x1_fit = np.linspace(ur.min(), 3, 200)\n",
            "x2_fit = np.linspace( 1,ur.max(), 200)\n",
            "g_azul= gauss(x1_fit,params[0],params[1],params[2])\n",
            "g_rojo= gauss(x2_fit,params[3],params[4],params[5])\n",
            "\n",
            "def diferencia(x):\n",
            "    return gauss(x,params[0],params[1],params[2]) - gauss(x,params[3],params[4],params[5])\n",
            "x_inicial= (params[4]+params[1])/2\n",
            "x_cruce = opt.fsolve(diferencia, x_inicial)[0]"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# PRIMEROS GRÁFICOS\n",
            "\n",
            "gl = 49  # cantidad de bines -1  \n",
            "chi_c = st.chi2.ppf((1-0.05), gl)\n",
            "p_c = 0.05\n",
            "\n",
            "# Usar los centros del histograma para ambos\n",
            "observadas = cuentas  # frecuencias observadas del histograma\n",
            "esperadas = doble_gaussiana(centros, *params)  # frecuencias esperadas del ajuste\n",
            "\n",
            "# Normalizar para que las sumas coincidan (importante para el test)\n",
            "esperadas = esperadas * np.sum(observadas) / np.sum(esperadas)\n",
            "\n",
            "chi2, p_value1 = st.chisquare(observadas, esperadas)\n",
            "\n",
            "print(\" TEST CHI-CUADRADO PARA BONDAD DE AJUSTE:\")\n",
            "print(f\"   Chi² = {chi2:.4f}, Chi critico = {chi_c:.4f} \")\n",
            "print(f\"   p-value = {p_value1:.4f}\")\n",
            "print(f\"   Grados de libertad = {gl}\")\n",
            "print('Usando como test estadístico al valor de p')\n",
            "if p_value1 < p_c:\n",
            "    print(\"   RESULTADO: Rechazamos H₀ - El ajuste NO es bueno\")\n",
            "else:\n",
            "    print(\"   RESULTADO: No rechazamos H₀ - El ajuste es aceptable\")\n",
            "print('Usando como test estadístico al chi²')\n",
            "if chi2 >= chi_c:\n",
            "    print(\"   RESULTADO: Rechazamos H₀ - El ajuste NO es bueno\")\n",
            "else:\n",
            "    print(\"   RESULTADO: No rechazamos H₀ - El ajuste es aceptable\")\n",
            "\n",
            "sns.histplot((df['u']-df['r']),bins=50,alpha=0.75,stat='density')\n",
            "plt.plot(x_fit, doble_gaussiana(x_fit, *params), label='Ajuste Doble Gaussiana', color='darkslategray')\n",
            "plt.plot(x1_fit, g_azul,  label='Gaussiana para azules',color=color_a) \n",
            "plt.plot(x2_fit, g_rojo, color=color_r, label='Gaussiana para rojas') \n",
            "plt.xlim(0.25,4.5)\n",
            "plt.xlabel('u-r')\n",
            "plt.legend()\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/ur.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ELIPTICAS Y ESPIRALES\n",
            "\n",
            "sns.histplot((elip['u']- elip['r']),bins=100,alpha=0.75,stat='density')\n",
            "sns.histplot((esp['u']- esp['r']),bins=100,alpha=0.75,stat='density')\n",
            "plt.xlim(0.25,4.5)\n",
            "plt.xlabel('g-r')\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/ur_morf.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()  \n",
            "\n",
            "sns.histplot((elip['g']- elip['r']),bins=100,alpha=0.75,stat='density')\n",
            "sns.histplot((esp['g']- esp['r']),bins=100,alpha=0.75,stat='density')\n",
            "plt.xlim(0,1.75)\n",
            "plt.xlabel('g-r')\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/gr_morf.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()  \n",
            "\n",
            "sns.histplot((elip['u']-elip['g']),bins=100,alpha=0.75,stat='density')\n",
            "sns.histplot((esp['u']-esp['g']),bins=100,alpha=0.75,stat='density')\n",
            "plt.xlim(0.25,3.75)\n",
            "plt.xlabel('u-g')\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/ug_morf.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# TEST DE UNIFORMIDAD PARA TIPOS DE GALAXIAS\n",
            " \n",
            "cantidad_elip = len(elip)\n",
            "cantidad_esp = len(esp)\n",
            "cantidad_mer = len(mer)\n",
            "data = {\n",
            "    'Tipo': ['Elípticas', 'Espirales', 'Merger'],\n",
            "    'Cantidad': [cantidad_elip, cantidad_esp, cantidad_mer]\n",
            "}\n",
            "df_tipos = pd.DataFrame(data)\n",
            "cant= sum(data['Cantidad'])\n",
            "\n",
            "chi_norm=[]\n",
            "grados_libertad=2 #cantidad de bines -1  \n",
            "chi_critico=st.chi2.ppf((1-0.05),grados_libertad)\n",
            "p_critico=0.05\n",
            "\n",
            "\n",
            "esperado_uniforme = [cant/3, cant/3, cant/3]\n",
            "chi2, p_value1 = st.chisquare(data['Cantidad'], esperado_uniforme)\n",
            "\n",
            "print(\" TEST CONTRA DISTRIBUCIÓN UNIFORME:\")\n",
            "print(f\"   Observado: {data['Cantidad']}\")\n",
            "print(f\"   Esperado:  {[int(x) for x in esperado_uniforme]}\")\n",
            "print(f\"   Chi² = {chi2:.4f}, Chi critico = {chi_critico:.4f} \")\n",
            "print(f\"   p-value = {p_value1:.4f}\")\n",
            "print(f\"   Grados de libertad = {grados_libertad}\")\n",
            "print('Usando como test estadístico al valor de p')\n",
            "if p_value1 < p_critico:\n",
            "    print(\"   RESULTADO: Rechazamos H₀ - La distribución NO es uniforme\")\n",
            "else:\n",
            "    print(\"   RESULTADO: No rechazamos H₀ - La distribución podría ser uniforme\")\n",
            "print('Usando como test estadístico al chi²')\n",
            "if chi2 >= chi_critico:\n",
            "    print(\"   RESULTADO: Rechazamos H₀ - La distribución NO es uniforme\")\n",
            "else:\n",
            "    print(\"   RESULTADO: No rechazamos H₀ - La distribución podría ser uniforme\")\n",
            "\n",
            "# Crear el gráfico con seaborn\n",
            "plt.figure(figsize=(10, 6))\n",
            "colors = [color_r, color_a, \"#8732cd\"]  # Rojo, azul, verde\n",
            "\n",
            "# Crear el barplot\n",
            "ax = sns.barplot(data=df_tipos, x='Tipo', y='Cantidad',palette=colors, alpha=0.7,hue='Tipo')\n",
            "ax1 = sns.barplot(data=df_tipos, x='Tipo', y=esperado_uniforme,color='lightsteelblue',alpha=0.1, hatch='/',label='Distribución uniforme')\n",
            "# Personalizar el gráfico\n",
            "plt.ylabel('Cantidad de galaxias')\n",
            "plt.xlabel('Tipo de galaxia')\n",
            "plt.legend()\n",
            "plt.title('Distribución de tipos de galaxias (con umbral > 0.8)')\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/morfologia.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# ROJOS Y AZULES\n",
            "sns.histplot((rojo['u']-rojo['r']),bins=10,alpha=0.75,stat='density',label='rojas',color=color_r)\n",
            "sns.histplot((azul['u']-azul['r']),bins=10,alpha=0.75,stat='density',label='azules',color=color_a)\n",
            "plt.xlim(0.25,4.5)\n",
            "plt.xlabel('u-r')\n",
            "plt.show()\n",
            "sns.histplot((rojo['g']-rojo['r']),bins=100,alpha=0.75,stat='density',label='rojas',color=color_r)\n",
            "sns.histplot((azul['g']-azul['r']),bins=100,alpha=0.75,stat='density',label='azules',color=color_a)\n",
            "plt.xlim(0,1.75)\n",
            "plt.xlabel('g-r')\n",
            "plt.show()\n",
            "sns.histplot((rojo['u']-rojo['g']),bins=100,alpha=0.75,stat='density',label='rojas',color=color_r)\n",
            "sns.histplot((azul['u']-azul['g']),bins=100,alpha=0.75,stat='density',label='azules',color=color_a)\n",
            "plt.xlim(0.25,3.75)\n",
            "plt.xlabel('u-g')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# BULGE Y DISCO\n",
            "fig, axes = plt.subplots(2, 1,figsize=(8, 12))\n",
            "sns.histplot(bulge['elip'],bins='auto',alpha=0.75,stat='density')\n",
            "sns.histplot(disco['elip'],bins='auto',alpha=0.75,stat='density')\n",
            "axes[0].set_xlim(0,1)\n",
            "axes[0].set_xlabel('elipticas')\n",
            "axes[0].set_title('Histograma del Porcentaje de elipticidad')\n",
            "sns.histplot(bulge['esp'],bins='auto',alpha=0.75,stat='density')\n",
            "sns.histplot(disco['esp'],bins='auto',alpha=0.75,stat='density')\n",
            "axes[1].set_xlim(0,1)\n",
            "axes[1].set_xlabel('espirales')\n",
            "plt.show()\n",
            "\n",
            "# ESPIRALES Y ELIPTICAS\n",
            "\n",
            "fig, axes = plt.subplots(2, 1,figsize=(8, 12))\n",
            "\n",
            "axes[0].hist(esp['fracDeV_r'],bins=10,alpha=0.75)\n",
            "\n",
            "axes[0].set_xlabel('fracDeV')\n",
            "\n",
            "axes[1].hist(elip['fracDeV_r'],bins=10,alpha=0.75)\n",
            "\n",
            "axes[1].set_xlabel('fracDeV')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# AJUSTE LINEAL DE UNA MUESTRA\n",
            "\n",
            "a_elip, b_elip = cuad_min(elip['g'], elip['r'])\n",
            "y_elip = a_elip * elip['g'] + b_elip\n",
            "a_esp, b_esp = cuad_min(esp['g'], esp['r'])\n",
            "y_esp = a_esp * esp['g'] + b_esp\n",
            "\n",
            "fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
            "\n",
            "# Primer subplot - Muestra general\n",
            "sns.scatterplot(x=muestra['g'], y=muestra['r'], alpha=0.6, label='10% de los Datos originales', ax=axes[0])\n",
            "axes[0].plot(muestra['g'], y, color=color_r, alpha=0.8, label=f'Ajuste: r = {a:.3f}g + {b:.3f}')\n",
            "axes[0].set_ylim(14.25, 17.65)\n",
            "axes[0].set_xlabel('g')\n",
            "axes[0].set_ylabel('r')\n",
            "axes[0].legend()\n",
            "axes[0].set_title('Ajuste lineal g vs r - Muestra general')\n",
            "\n",
            "# Segundo subplot - Galaxias espirales\n",
            "sns.scatterplot(x=esp['g'], y=esp['r'], alpha=0.6, label='Galaxias Espirales', ax=axes[1])\n",
            "axes[1].plot(esp['g'], y_esp, color=color_r, alpha=0.8, label=f'Ajuste: r = {a_esp:.3f}g + {b_esp:.3f}')\n",
            "axes[1].set_ylim(14.25, 17.65)\n",
            "axes[1].set_xlabel('g')\n",
            "axes[1].set_ylabel('r')\n",
            "axes[1].legend()\n",
            "axes[1].set_title('Ajuste lineal g vs r - Espirales')\n",
            "\n",
            "# Tercer subplot - Galaxias elípticas\n",
            "sns.scatterplot(x=elip['g'], y=elip['r'], alpha=0.6, label='Galaxias Elípticas', ax=axes[2])\n",
            "axes[2].plot(elip['g'], y_elip, color=color_r, alpha=0.8, label=f'Ajuste: r = {a_elip:.3f}g + {b_elip:.3f}')\n",
            "axes[2].set_ylim(14.25, 17.65)\n",
            "axes[2].set_xlabel('g')\n",
            "axes[2].set_ylabel('r')\n",
            "axes[2].legend()\n",
            "axes[2].set_title('Ajuste lineal g vs r - Elípticas')\n",
            "\n",
            "plt.tight_layout()\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/ajustes_lineales_comparacion.pdf', dpi=300, bbox_inches='tight')\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# MAGNITUD ABSOLUTA VS z\n",
            "c=300000\n",
            "H0=75\n",
            "M_abs= df['r']-25-5*np.log10(c*df['z']/H0)\n",
            "\n",
            "\n",
            "def f(x):\n",
            "    f=a*np.log10(x+b)\n",
            "\n",
            "\n",
            "plt.figure(figsize=(8, 6))\n",
            "sns.scatterplot(x=df['z'],y=M_abs, alpha=0.6, label='Datos originales')\n",
            "#plt.plot(muestra['g'], y, color=color_r, alpha=0.8, label=f'Ajuste: r = {a:.3f}g + {b:.3f}')\n",
            "plt.xlim(-0.005,0.25)\n",
            "plt.ylim(-25,-5)\n",
            "plt.xlabel('$z$')\n",
            "plt.ylabel('$M_r$')\n",
            "plt.legend()\n",
            "plt.title('Magnitud absoluta en r vs $z$')\n",
            "plt.savefig('/mnt/sda2/astrometria/practico_3/informe/imagenes/mabs.pdf',dpi=300,bbox_inches='tight')\n",
            "plt.show()"
        ]
    }
]

# Crear la estructura del notebook
notebook = {
    "cells": cells,
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.8.5"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 4
}

# Guardar el notebook
with open('/mnt/sda2/astrometria/practico_3/pr3.ipynb', 'w', encoding='utf-8') as f:
    json.dump(notebook, f, indent=2, ensure_ascii=False)

print("Notebook creado exitosamente: /mnt/sda2/astrometria/practico_3/pr3.ipynb")
